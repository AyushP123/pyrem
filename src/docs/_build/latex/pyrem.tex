% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{pyrem Documentation}
\date{September 07, 2014}
\release{1.0}
\author{Quentin Geissmann}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Module contents}
\label{index:module-contents}\label{index:welcome-to-pyrem-s-documentation}\label{index:module-pyrem}\index{pyrem (module)}
Pyrem is a python package to help feature extraction from physiological time series such as electroencephalograms(EEGs) and such.

It provides:
\begin{enumerate}
\item {} 
Data structures for time series ({\hyperref[pyrem.time_series:module-pyrem.time_series]{\code{pyrem.time\_series}}}) based on numpy arrays. This extends functionality of numpy arrays by:
\begin{enumerate}
\item {} 
Providing extra attributes such as sampling frequency and metadata

\item {} 
Allow new functionality such as time-string indexing (e.g. \code{signal{[}"28m":"2h22.4s"{]}})

\end{enumerate}

\item {} 
A data structure for annotations ({\hyperref[pyrem.time_series:pyrem.time_series.Annotation]{\code{pyrem.time\_series.Annotation}}}) based on numpy recarrays. This allows to describe time series of discrete states linked to a confidence/probability of observation of each states.

\item {} 
A data structure for collection of time series ({\hyperref[pyrem.polygram:module-pyrem.polygram]{\code{pyrem.polygram}}}). It features:
\begin{enumerate}
\item {} 
Support for heterogeneous sampling rates between time series.

\item {} 
An iterator through arbitrary epochs (temporal slices)

\item {} 
Slicing using time strings and seamless merging between polygrams

\end{enumerate}

\item {} 
Implementations of algorithms often used in analysis of EEGs (see {\hyperref[pyrem.univariate:module-pyrem.univariate]{\code{pyrem.univariate}}}). They are essentially  faster and curated reimplementation of the function available in \href{http://www.hindawi.com/journals/cin/2011/406391/}{PyEEG}.

\item {} 
Utilities to load, save and visualize the data (still in development).

\item {} 
Wrappers around \href{http://www.ar.media.kyoto-u.ac.jp/members/david/softwares/samplerate/sphinx/index.html}{samplerate} and \href{http://www.pybytes.com/pywavelets/}{pywt} libraries, to efficiently resample, and compute discrete wavelet decomposition on signals.

\end{enumerate}


\chapter{Submodules}
\label{index:pywt}\label{index:submodules}

\section{pyrem.time\_series module}
\label{pyrem.time_series:pyrem-time-series-module}\label{pyrem.time_series:module-pyrem.time_series}\label{pyrem.time_series::doc}\index{pyrem.time\_series (module)}

\subsection{Biological time series}
\label{pyrem.time_series:biological-time-series}
This module provides data structure for two types of time series: {\hyperref[pyrem.time_series:pyrem.time_series.Signal]{\code{Signal}}} and {\hyperref[pyrem.time_series:pyrem.time_series.Annotation]{\code{Annotation}}}.

Both structures extend \href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}} by providing attributes, such as \emph{sampling frequency}, \emph{metadata}, name.
More importantly, time series provide specific features such as indexing with time strings.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pyrem} \PYG{k+kn}{as} \PYG{n+nn}{pr}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} generate white noise:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{noise} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{1e6}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} a million point sampled at 256 Hz}
\end{Verbatim}

Then, to create a time series from this vector of random numbers:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig} \PYG{o}{=} \PYG{n}{pr}\PYG{o}{.}\PYG{n}{time\PYGZus{}series}\PYG{o}{.}\PYG{n}{Signal}\PYG{p}{(}\PYG{n}{noise}\PYG{p}{,} \PYG{l+m+mf}{256.0}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                            \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{noise}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{channel\PYGZus{}1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                            \PYG{n}{metadata}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{patient}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{John\PYGZus{}Doe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{Verbatim}

Display information about this time series:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig}
\end{Verbatim}

To resample at 100 Hz:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig\PYGZus{}short} \PYG{o}{=}  \PYG{n}{sig}\PYG{o}{.}\PYG{n}{resample}\PYG{p}{(}\PYG{l+m+mf}{100.0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig\PYGZus{}short}
\end{Verbatim}

Time series derive from numpy arrays, so you can just use them as such:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig\PYGZus{}norm} \PYG{o}{=} \PYG{n}{sig} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{sig}\PYG{p}{)}
\PYG{g+go}{Note that the resulting signal is conveniently a time series (not a regular numpy array)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{sig}\PYG{p}{)}
\end{Verbatim}


\subsection{Indexing time series}
\label{pyrem.time_series:indexing-time-series}

\subsubsection{As numpy arrays}
\label{pyrem.time_series:as-numpy-arrays}
Since time series are derived from numpy array, the numpy indexing rule apply:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{1000}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{c}{\PYGZsh{} one to 999, every 3 values}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig}\PYG{p}{[}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{]} \PYG{c}{\PYGZsh{} from start to 0 to 100 before the end}
\end{Verbatim}

See numpy documentation for more info.


\subsubsection{With strings and time-deltas}
\label{pyrem.time_series:with-strings-and-time-deltas}
It is common to have to extract a signal between two different time points.
Instead of having to tediously calculate index from time, \emph{pyrem}  offers the possibility to use stings and \href{http://docs.python.org/2.7/library/datetime.html\#datetime.timedelta}{\code{datetime.timedelta}}

Time strings are represented with the following format:

\emph{``29h33m1.02s''}

Where:
\begin{itemize}
\item {} 
h is for hour

\item {} 
m for minutes

\item {} 
s for seconds

\end{itemize}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} string indexing:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{sig}\PYG{o}{.}\PYG{n}{duration}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig2} \PYG{o}{=} \PYG{n}{sig}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1h2m2s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{p}{]}  \PYG{c}{\PYGZsh{} everything after 1 hour, 2 min and 2 seconds}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{sig2}\PYG{o}{.}\PYG{n}{duration}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} this should be exactly 1h2m2s}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{sig}\PYG{o}{.}\PYG{n}{duration} \PYG{o}{\PYGZhy{}} \PYG{n}{sig2}\PYG{o}{.}\PYG{n}{duration}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{sig}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1h2m2s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1h2m2.1s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}
\end{Verbatim}

\begin{notice}{note}{Note:}
When indexing a signal with time strings, we query the values of a \emph{discrete representation of a continuous signal}.
Therefore, it makes no sense to obtain a signal of length zero.
For instance, imagine a signal of 10 seconds sampled at 1Hz. If we query the value between 1.5 and 1.6s, no points
fall in this interval. However, the signal does have a value.
In this case, \emph{pyrem} returns a signal of length 1 where the unique value is the value of the former neighbour.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig} \PYG{o}{=} \PYG{n}{pr}\PYG{o}{.}\PYG{n}{time\PYGZus{}series}\PYG{o}{.}\PYG{n}{Signal}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{10.0}\PYG{p}{,}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.001s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.011s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}


\subsubsection{Epoch iteration}
\label{pyrem.time_series:epoch-iteration}
A common task is to extract successive temporal slices (i.e. epochs) of a signal, for instance, in order to compute features.
{\hyperref[pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.iter_window]{\code{iter\_window()}}} iterator facilitates this.

Let us work wit a one minute signal as an example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig1m} \PYG{o}{=} \PYG{n}{sig}\PYG{p}{[}\PYG{p}{:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1m}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}
\end{Verbatim}

Get every 5 seconds of a the first minutes of a signal:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{time}\PYG{p}{,} \PYG{n}{sub\PYGZus{}signal} \PYG{o+ow}{in} \PYG{n}{sig1m}\PYG{o}{.}\PYG{n}{iter\PYGZus{}window}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{print} \PYG{n}{time}\PYG{p}{,} \PYG{n}{sub\PYGZus{}signal}\PYG{o}{.}\PYG{n}{duration}
\end{Verbatim}

Get 10 second epochs, overlapping of 50\% (5s):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{time}\PYG{p}{,} \PYG{n}{sub\PYGZus{}signal} \PYG{o+ow}{in} \PYG{n}{sig1m}\PYG{o}{.}\PYG{n}{iter\PYGZus{}window}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{print} \PYG{n}{time}\PYG{p}{,} \PYG{n}{sub\PYGZus{}signal}\PYG{o}{.}\PYG{n}{duration}
\end{Verbatim}

Get 1 second epochs, skipping every other epoch

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{time}\PYG{p}{,} \PYG{n}{sub\PYGZus{}signal} \PYG{o+ow}{in} \PYG{n}{sig1m}\PYG{o}{.}\PYG{n}{iter\PYGZus{}window}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{print} \PYG{n}{time}\PYG{p}{,} \PYG{n}{sub\PYGZus{}signal}\PYG{o}{.}\PYG{n}{duration}
\end{Verbatim}
\index{Annotation (class in pyrem.time\_series)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.Annotation}\pysiglinewithargsret{\strong{class }\code{pyrem.time\_series.}\bfcode{Annotation}}{\emph{data}, \emph{fs}, \emph{observation\_probabilities=None}, \emph{**kwargs}}{}
Bases: {\hyperref[pyrem.time_series:pyrem.time_series.BiologicalTimeSeries]{\code{pyrem.time\_series.BiologicalTimeSeries}}}

Annotations are time series of discrete values associated with a probability/confidence of observing this value.
{\hyperref[pyrem.time_series:pyrem.time_series.BiologicalTimeSeries]{\code{BiologicalTimeSeries}}} indexing rules apply to them.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{data} -- a vector representing different states.            It should be a uint8 one-d array like structure (typically, a \href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}})

\item {} 
\textbf{fs} (\href{http://docs.python.org/2.7/library/functions.html\#float}{\emph{float}}) -- the sampling frequency

\item {} 
\textbf{observation\_probabilities} -- an array of confidence/ probability of observation of the states.
it should be a one-d array-like of floats of length \emph{len(data)}.
If \emph{None}, confidence are assumed to be equal to one for all observations.

\item {} 
\textbf{kwargs} -- key word arguments to be passed to {\hyperref[pyrem.time_series:pyrem.time_series.BiologicalTimeSeries]{\code{BiologicalTimeSeries}}}

\end{itemize}

\end{description}\end{quote}
\index{probas (pyrem.time\_series.Annotation attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.Annotation.probas}\pysigline{\bfcode{probas}}
The probabilities/confidences associated to the annotation values.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
an array of \code{float32}

\item[{Return type}] \leavevmode
\href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}}

\end{description}\end{quote}

\end{fulllineitems}

\index{resample() (pyrem.time\_series.Annotation method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.Annotation.resample}\pysiglinewithargsret{\bfcode{resample}}{\emph{target\_fs}}{}
Resample annotations to a new sampling frequency.
Values are resampled with nearest neighbour interpolation,
while associated probabilities are linearly interpolated.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{target\_fs} (\href{http://docs.python.org/2.7/library/functions.html\#float}{\emph{float}}) -- The target sampling frequency

\item[{Returns}] \leavevmode
a new  {\hyperref[pyrem.time_series:pyrem.time_series.Annotation]{\code{Annotation}}} object

\end{description}\end{quote}

\end{fulllineitems}

\index{values (pyrem.time\_series.Annotation attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.Annotation.values}\pysigline{\bfcode{values}}
The values of each annotations.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
an array of \code{uint8}

\item[{Return type}] \leavevmode
\href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{BiologicalTimeSeries (class in pyrem.time\_series)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.BiologicalTimeSeries}\pysiglinewithargsret{\strong{class }\code{pyrem.time\_series.}\bfcode{BiologicalTimeSeries}}{\emph{data}, \emph{fs}, \emph{type=None}, \emph{name=None}, \emph{metadata=None}}{}
Bases: \href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{numpy.ndarray}}

An abstract class for time series.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{data} -- an one-d array like structure (typically, a \href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}})

\item {} 
\textbf{fs} (\href{http://docs.python.org/2.7/library/functions.html\#float}{\emph{float}}) -- the sampling frequency

\item {} 
\textbf{type} (\href{http://docs.python.org/2.7/library/functions.html\#str}{\emph{str}}) -- the type of time series (e.g. ``eeg'', ``temperature'', ``blood\_pH'')

\item {} 
\textbf{name} (\href{http://docs.python.org/2.7/library/functions.html\#str}{\emph{str}}) -- a unique name to identify a time series contained in a {\hyperref[pyrem.polygram:pyrem.polygram.Polygram]{\code{Polygram}}}

\item {} 
\textbf{metadata} (\href{http://docs.python.org/2.7/library/stdtypes.html\#dict}{\emph{dict}}) -- a dictionary of additional information (e.g. experimental variables)

\end{itemize}

\end{description}\end{quote}
\index{copy() (pyrem.time\_series.BiologicalTimeSeries method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Deep copy a time series.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A new time series with identical values and attributes

\item[{Return type}] \leavevmode
{\hyperref[pyrem.time_series:pyrem.time_series.BiologicalTimeSeries]{\code{BiologicalTimeSeries}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{duration (pyrem.time\_series.BiologicalTimeSeries attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.duration}\pysigline{\bfcode{duration}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the total duration of the time series

\item[{Return type}] \leavevmode
datetime

\end{description}\end{quote}

\end{fulllineitems}

\index{fs (pyrem.time\_series.BiologicalTimeSeries attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.fs}\pysigline{\bfcode{fs}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the sampling frequency of the time series

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{iter\_window() (pyrem.time\_series.BiologicalTimeSeries method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.iter_window}\pysiglinewithargsret{\bfcode{iter\_window}}{\emph{length}, \emph{lag}}{}
Iterate through an array by successive (possibly overlapping) slices (i.e. epochs).
Conveniently, the central time ot the epoch is also returned.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{lag} (\href{http://docs.python.org/2.7/library/functions.html\#float}{\emph{float}}) -- the ratio of overlap (1 = no overlap, 0 = completely overlapped, 2 = skip every other epoch)

\item {} 
\textbf{length} (\href{http://docs.python.org/2.7/library/functions.html\#float}{\emph{float}}) -- duration of the epochs (in second)

\end{itemize}

\item[{Returns}] \leavevmode
(centre\_of\_window, {\hyperref[pyrem.time_series:pyrem.time_series.BiologicalTimeSeries]{\code{BiologicalTimeSeries}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{metadata (pyrem.time\_series.BiologicalTimeSeries attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.metadata}\pysigline{\bfcode{metadata}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a dictionary of metadata (i.e. information about data acquisition)

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{name (pyrem.time\_series.BiologicalTimeSeries attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.name}\pysigline{\bfcode{name}}
The name of the signal. It is expected to be unique.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the user-defined name for this signal

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{rename() (pyrem.time\_series.BiologicalTimeSeries method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.rename}\pysiglinewithargsret{\bfcode{rename}}{\emph{name}}{}
Rename the signal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{name} (\href{http://docs.python.org/2.7/library/functions.html\#str}{\emph{str}}) -- the new name

\end{description}\end{quote}

\end{fulllineitems}

\index{resample() (pyrem.time\_series.BiologicalTimeSeries method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.resample}\pysiglinewithargsret{\bfcode{resample}}{\emph{new\_fs}}{}
Abstract method for resampling a time series (behaves differently according to the type of time series)

\begin{notice}{note}{Note:}
Because time series are digital (i.e. discrete) the resulting sampling rate is expected to be
slightly different from the target sampling rate.
\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{new\_fs} (\href{http://docs.python.org/2.7/library/functions.html\#float}{\emph{float}}) -- the target time series

\item[{Returns}] \leavevmode
a new {\hyperref[pyrem.time_series:pyrem.time_series.BiologicalTimeSeries]{\code{BiologicalTimeSeries}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (pyrem.time\_series.BiologicalTimeSeries method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.save}\pysiglinewithargsret{\bfcode{save}}{\emph{filename}, \emph{compression\_level=5}}{}
Efficiently save a time series using joblib
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\href{http://docs.python.org/2.7/library/functions.html\#str}{\emph{str}}) -- the output file name

\item {} 
\textbf{compression\_level} (\href{http://docs.python.org/2.7/library/functions.html\#int}{\emph{int}}) -- an integer between 1 and 9. More is better, but slower. 5 is generally a good compromise

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{type (pyrem.time\_series.BiologicalTimeSeries attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.type}\pysigline{\bfcode{type}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the user-defined type of time series (e.g. ``eeg'' or ``ecg'')

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Signal (class in pyrem.time\_series)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.Signal}\pysiglinewithargsret{\strong{class }\code{pyrem.time\_series.}\bfcode{Signal}}{\emph{data}, \emph{fs}, \emph{**kwargs}}{}
Bases: {\hyperref[pyrem.time_series:pyrem.time_series.BiologicalTimeSeries]{\code{pyrem.time\_series.BiologicalTimeSeries}}}
\index{resample() (pyrem.time\_series.Signal method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.time_series:pyrem.time_series.Signal.resample}\pysiglinewithargsret{\bfcode{resample}}{\emph{target\_fs}, \emph{mode='sinc\_best'}}{}
Resample the signal. One implication of the signal being digital, is that the resulting sampling
frequency is not guaranteed to be exactly at \emph{target\_fs}.
This method wraps \code{resample()}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{target\_fs} (\href{http://docs.python.org/2.7/library/functions.html\#float}{\emph{float}}) -- The new sampling frequency

\item {} 
\textbf{mode} (\href{http://docs.python.org/2.7/library/functions.html\#str}{\emph{str}}) -- to be passed to \href{http://www.ar.media.kyoto-u.ac.jp/members/david/softwares/samplerate/sphinx/fullapi.html\#scikits.samplerate.resample}{\code{resample()}}

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{pyrem.polygram module}
\label{pyrem.polygram:module-pyrem.polygram}\label{pyrem.polygram:pyrem-polygram-module}\label{pyrem.polygram::doc}\index{pyrem.polygram (module)}

\subsection{Polygram}
\label{pyrem.polygram:polygram}
This module provides {\hyperref[pyrem.polygram:pyrem.polygram.Polygram]{\code{Polygram}}}; a container for biological time series
such as {\hyperref[pyrem.time_series:pyrem.time_series.Signal]{\code{Signal}}} and {\hyperref[pyrem.time_series:pyrem.time_series.Annotation]{\code{Annotation}}}.
In this respect, it is inspired from pandas \code{TimeSeries} and \href{http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html\#pandas.DataFrame}{\code{DataFrame}}.
You can think about it as a dataframe where each column is a signal, or an annotation, and each row a time point.

The originality of :\emph{\textasciitilde{}pyrem.polygram.Polygram} is to be able to deal with \textbf{heterogeneous (between signals) sampling rates}.
It contains time series with the same approximate duration, but different number of points.
This is typical when dealing with physiological time series because different variable will be
recorded at different sampling rates (see for instance, the {\hyperref[pyrem.polygram:edf]{{[}EDF{]}}} data format).
Another situation it which this could  be useful, is when performing a wavelet decomposition of a signal.
Indeed, one would obtain a set of time series (coefficients) of the same duration, but with different sampling rates (i.e. \(fs_{D_N} = 2fs_{D_{N+1}}\)).

Systematically resampling signals, and annotations, to the maximal sampling rate is not  trivial, and would impact
significantly computational efficiency.


\subsubsection{Constructing a Polygram}
\label{pyrem.polygram:constructing-a-polygram}
First, let us create a couple of \code{BiolgicalTimeSeries}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pyrem.time\PYGZus{}series} \PYG{k+kn}{import} \PYG{n}{Annotation}\PYG{p}{,} \PYG{n}{Signal}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pyrem.polygram} \PYG{k+kn}{import} \PYG{n}{Polygram}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} create an Annotation with 1000 random values, sampled at 1.0Hz}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{probs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{vals} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{4} \PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{annot} \PYG{o}{=} \PYG{n}{Annotation}\PYG{p}{(}\PYG{n}{vals}\PYG{p}{,}\PYG{n}{fs}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{observation\PYGZus{}probabilities}\PYG{o}{=}\PYG{n}{probs}\PYG{p}{,} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{vigilance\PYGZus{}state}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{state}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} now a random walk signal of 100000 points at 100.0Hz}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rw} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cumsum}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig} \PYG{o}{=} \PYG{n}{Signal}\PYG{p}{(}\PYG{n}{rw}\PYG{p}{,} \PYG{n}{fs}\PYG{o}{=}\PYG{l+m+mf}{100.0}\PYG{p}{,}\PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{eeg}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{eeg1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} Once we have our time series, we can just do:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pol} \PYG{o}{=} \PYG{n}{Polygram}\PYG{p}{(}\PYG{p}{[}\PYG{n}{annot}\PYG{p}{,} \PYG{n}{sig}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{}printing the object shows the characteristic of each channels}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pol}
\PYG{g+go}{Polygram}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{Duration:       0:16:40 (HH:mm:ss)}
\PYG{g+go}{N signals:      1}
\PYG{g+go}{N annotations:  1}
\PYG{g+go}{Metadata:}
\PYG{g+go}{                None}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{Channel information:}
\PYG{g+go}{    Name             Type fs(Hz) Duration}
\PYG{g+go}{0   eeg1              eeg  100.0  0:16:40}
\PYG{g+go}{1  state  vigilance\PYGZus{}state    1.0  0:16:40}
\end{Verbatim}

\begin{notice}{note}{Note:}
\textbf{Slightly different durations are allowed}

The constructor will raise an error if the provided channels do not have the same duration:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Polygram}\PYG{p}{(}\PYG{p}{[}\PYG{n}{annot}\PYG{p}{[}\PYG{p}{:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{11m}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sig}\PYG{p}{[}\PYG{p}{:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10m}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{ValueError}
\PYG{g+go}{\PYGZsq{}Channels must have approximately the same length.}
\PYG{g+go}{The durations of the input channels are:[\PYGZsq{}0:10:00\PYGZsq{}, \PYGZsq{}0:11:00\PYGZsq{}]\PYGZsq{}}
\end{Verbatim}

However, in practice, it is almost impossible to obtain discrete signal of the exact same duration.
Imagine, for instance that you have a first signal of 14 points at 3Hz (\textasciitilde{} 4.667s), and a second signal of 5 points at 1Hz (5.0s).
In this case, it is impossible to have exactly 14/3s of signal form a 1Hz signal.
This could be represented by:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mo}{01234567}\PYG{l+m+mi}{89}\PYG{n}{abcd}\PYG{o}{\PYGZhy{}}   \PYG{c}{\PYGZsh{}  3Hz =\PYGZgt{} one symbol/point}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{AAABBBCCCDDDEEE}   \PYG{c}{\PYGZsh{} 1Hz =\PYGZgt{} one LETTER/point}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{AAABBBCCCDDD}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}   \PYG{c}{\PYGZsh{} 1Hz =\PYGZgt{} one LETTER/point}
\end{Verbatim}

Here, neither the second nor the third signal match, exactly, the duration of the first, but bot are approximately the same duration as the first.

\textbf{A Polygram will tolerate this sort of mismatch if and only if all pairs of channels are within one period of the time series  with the channel longest period.}
\end{notice}


\subsubsection{Accessing channels}
\label{pyrem.polygram:accessing-channels}
Often, you will want to extract a channel by name:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pol}\PYG{o}{.}\PYG{n}{channel\PYGZus{}names}
\PYG{g+go}{[\PYGZsq{}eeg1\PYGZsq{}, \PYGZsq{}state\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pol}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{eeg1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{Signal}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{Name:   eeg1}
\PYG{g+go}{Duration:       0:16:40 (HH:mm:ss)}
\PYG{g+go}{Sampling freq:  100.000000 Hz}
\PYG{g+go}{Type:   eeg}
\PYG{g+go}{N points:       100000}
\PYG{g+go}{Metadata:}
\PYG{g+go}{                None}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} this is equivalent to}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pol}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

You can also iterate through channels:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{n}{c}\PYG{o}{.}\PYG{n}{size} \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n}{pol}\PYG{o}{.}\PYG{n}{channels}\PYG{p}{]}
\PYG{g+go}{[100000, 1000]}
\end{Verbatim}


\subsubsection{With strings and time-deltas}
\label{pyrem.polygram:with-strings-and-time-deltas}
Because time series are potentially at different sampling rates, it makes no sense to index a polygram by range of integers:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{}does NOT work}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} pol[10:20]}
\end{Verbatim}

Instead, time string and \href{http://docs.python.org/2.7/library/datetime.html\#datetime.timedelta}{\code{datetime.timedelta}} can be used for extracting a sub\_polygram:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pol}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1m}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2m}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}
\end{Verbatim}

Indexing rules are similar to {\hyperref[pyrem.time_series:module-pyrem.time_series]{\code{time\_series}}}

\begin{notice}{note}{Note:}
\textbf{Indexing does NOT deep copy}

When getting an epoch (temporal slice), of a polygram, the channel in the new polygram are \emph{views} to the underlying data of the original channel.
Like for numpy arrays, \emph{modifying the data in a sub-polygram will modify the parent polygram}. To avoid this behaviour, one can call {\hyperref[pyrem.polygram:pyrem.polygram.Polygram.copy]{\code{copy()}}}
\end{notice}


\subsubsection{Epoch iteration}
\label{pyrem.polygram:epoch-iteration}
If you want to extract features for each epoch and each channel, you may want to use th
{\hyperref[pyrem.polygram:pyrem.polygram.Polygram.iter_window]{\code{iter\_window()}}} iterator.
It works like the {\hyperref[pyrem.time_series:pyrem.time_series.BiologicalTimeSeries.iter_window]{\code{iter\_window()}}}
\index{Polygram (class in pyrem.polygram)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram}\pysiglinewithargsret{\strong{class }\code{pyrem.polygram.}\bfcode{Polygram}}{\emph{channels}, \emph{metadata=None}}{}
Bases: \code{object}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{channels} (list(\code{BiolgicalTimeSeries})) -- a list of time series with approximately the same duration

\item {} 
\textbf{metadata} (\href{http://docs.python.org/2.7/library/stdtypes.html\#dict}{\emph{dict}}) -- a dictionary of additional information (e.g. experimental variables)

\end{itemize}

\end{description}\end{quote}
\index{annotation\_channels (pyrem.polygram.Polygram attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.annotation_channels}\pysigline{\bfcode{annotation\_channels}}
An iterator through the all the \emph{annotation} channels

\end{fulllineitems}

\index{channel\_names (pyrem.polygram.Polygram attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.channel_names}\pysigline{\bfcode{channel\_names}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The list of channel names

\item[{Return type}] \leavevmode
list(str)

\end{description}\end{quote}

\end{fulllineitems}

\index{channel\_types (pyrem.polygram.Polygram attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.channel_types}\pysigline{\bfcode{channel\_types}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the types of all channels

\item[{Return type}] \leavevmode
list(str)

\end{description}\end{quote}

\end{fulllineitems}

\index{channels (pyrem.polygram.Polygram attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.channels}\pysigline{\bfcode{channels}}
An iterator through the all the channels

\end{fulllineitems}

\index{copy() (pyrem.polygram.Polygram method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Deep copy of an Polygram
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a new Polygram with the same values

\item[{Return type}] \leavevmode
{\hyperref[pyrem.polygram:pyrem.polygram.Polygram]{\code{Polygram}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{duration (pyrem.polygram.Polygram attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.duration}\pysigline{\bfcode{duration}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The duration total of the polygram. That is the duration of the channel with the longest duration

\item[{Return type}] \leavevmode
\href{http://docs.python.org/2.7/library/datetime.html\#datetime.timedelta}{\code{datetime.timedelta}}

\end{description}\end{quote}

\end{fulllineitems}

\index{iter\_window() (pyrem.polygram.Polygram method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.iter_window}\pysiglinewithargsret{\bfcode{iter\_window}}{\emph{length}, \emph{lag}}{}
\end{fulllineitems}

\index{map\_signal\_channels() (pyrem.polygram.Polygram method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.map_signal_channels}\pysiglinewithargsret{\bfcode{map\_signal\_channels}}{\emph{fun}}{}
Applies a function to all signal channels and returns a new Polygram with modified channels

An example of how to normalise all signal channels

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pol\PYGZus{}norm} \PYG{o}{=}  \PYG{n}{pol}\PYG{o}{.}\PYG{n}{map\PYGZus{}signal\PYGZus{}channels}\PYG{p}{(}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{pol}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{pol\PYGZus{}norm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{fun} (\href{http://docs.python.org/2.7/library/functions.html\#callable}{\emph{callable}}) -- a function to be applied

\item[{Returns}] \leavevmode
a new polygram

\item[{Return type}] \leavevmode
{\hyperref[pyrem.polygram:pyrem.polygram.Polygram]{\code{Polygram}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{merge() (pyrem.polygram.Polygram method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.merge}\pysiglinewithargsret{\bfcode{merge}}{\emph{obj}, \emph{trim\_channel=True}}{}
Adds channels from a polygram to another polygram, or append a time series to a polygram
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} ({\hyperref[pyrem.polygram:pyrem.polygram.Polygram]{\code{Polygram}}} or {\hyperref[pyrem.time_series:pyrem.time_series.BiologicalTimeSeries]{\code{BiologicalTimeSeries}}}) -- either a polygram or a time series to be added

\item {} 
\textbf{trim\_channel} (\href{http://docs.python.org/2.7/library/functions.html\#bool}{\emph{bool}}) -- whether the new channel(s), if they have a longer duration, would be shortened to match the existing polygram.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{metadata (pyrem.polygram.Polygram attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.metadata}\pysigline{\bfcode{metadata}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the metadata of this polygram

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_annotations (pyrem.polygram.Polygram attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.n_annotations}\pysigline{\bfcode{n\_annotations}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The total number of \emph{annotation} channels

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_channels (pyrem.polygram.Polygram attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.n_channels}\pysigline{\bfcode{n\_channels}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The total number of channels

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_signals (pyrem.polygram.Polygram attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.n_signals}\pysigline{\bfcode{n\_signals}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The total number of \emph{signal} channels

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (pyrem.polygram.Polygram method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.save}\pysiglinewithargsret{\bfcode{save}}{\emph{filename}, \emph{compression\_level=5}}{}
Efficiently save a Polygram using joblib
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\href{http://docs.python.org/2.7/library/functions.html\#str}{\emph{str}}) -- the output file name

\item {} 
\textbf{compression\_level} (\href{http://docs.python.org/2.7/library/functions.html\#int}{\emph{int}}) -- an integer between 1 and 9. More is better, but slower. 5 is generally a good compromise

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{show() (pyrem.polygram.Polygram method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.show}\pysiglinewithargsret{\bfcode{show}}{}{}
Interactively displays a polygram using matplotlib. \textbf{Very urresponsive and prototypical at the minute}

\end{fulllineitems}

\index{signal\_channels (pyrem.polygram.Polygram attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.polygram:pyrem.polygram.Polygram.signal_channels}\pysigline{\bfcode{signal\_channels}}
An iterator through the all the \emph{signal} channels

\end{fulllineitems}


\end{fulllineitems}



\section{pyrem.univariate module}
\label{pyrem.univariate:pyrem-univariate-module}\label{pyrem.univariate::doc}\label{pyrem.univariate:module-pyrem.univariate}\index{pyrem.univariate (module)}

\subsection{Feature computation for univariate time series}
\label{pyrem.univariate:feature-computation-for-univariate-time-series}
This sub-module provides routines for computing features on univariate time series.
Many functions are improved version of PyEEG {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}} functions. Be careful,
some functions will give different results compared to PyEEG as the maths have been changed to match original definitions.
Have a look at the documentation notes/ source code to know more.

Here a list of the functions that were reimplemented:
\begin{itemize}
\item {} 
Approximate entropy {\hyperref[pyrem.univariate:pyrem.univariate.ap_entropy]{\code{ap\_entropy()}}} {\hyperref[pyrem.univariate:ric00]{{[}RIC00{]}}}

\item {} 
Fisher information {\hyperref[pyrem.univariate:pyrem.univariate.fisher_info]{\code{fisher\_info()}}} {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}}

\item {} 
Higuchi fractal dimension  {\hyperref[pyrem.univariate:pyrem.univariate.hfd]{\code{hfd()}}} {\hyperref[pyrem.univariate:hig88]{{[}HIG88{]}}}

\item {} 
Hjorth parameters {\hyperref[pyrem.univariate:pyrem.univariate.hjorth]{\code{hjorth()}}} {\hyperref[pyrem.univariate:hjo70]{{[}HJO70{]}}}

\item {} 
Petrosian fractal dimension {\hyperref[pyrem.univariate:pyrem.univariate.pfd]{\code{pfd()}}} {\hyperref[pyrem.univariate:pet95]{{[}PET95{]}}}

\item {} 
Sample entropy {\hyperref[pyrem.univariate:pyrem.univariate.samp_entropy]{\code{samp\_entropy()}}} {\hyperref[pyrem.univariate:ric00]{{[}RIC00{]}}}

\item {} 
Singular value decomposition entropy {\hyperref[pyrem.univariate:pyrem.univariate.svd_entropy]{\code{svd\_entropy()}}} {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}}

\item {} 
Spectral entropy {\hyperref[pyrem.univariate:pyrem.univariate.spectral_entropy]{\code{spectral\_entropy()}}} {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}}

\end{itemize}
\index{ap\_entropy() (in module pyrem.univariate)}

\begin{fulllineitems}
\phantomsection\label{pyrem.univariate:pyrem.univariate.ap_entropy}\pysiglinewithargsret{\code{pyrem.univariate.}\bfcode{ap\_entropy}}{\emph{a}, \emph{m}, \emph{R}}{}
Compute the approximate entropy of a signal with embedding dimension ``de'' and delay ``tau'' {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}}.
Vectorised version of the PyEEG function. Faster than PyEEG, but still critically slow.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{a} (\href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}} or {\hyperref[pyrem.time_series:pyrem.time_series.Signal]{\code{Signal}}}) -- a one dimensional floating-point array representing a time series.

\item {} 
\textbf{m} (\href{http://docs.python.org/2.7/library/functions.html\#int}{\emph{int}}) -- the scale

\item {} 
\textbf{R} (\emph{float{}`}) -- The tolerance

\end{itemize}

\item[{Returns}] \leavevmode
the approximate entropy, a scalar

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{dfa() (in module pyrem.univariate)}

\begin{fulllineitems}
\phantomsection\label{pyrem.univariate:pyrem.univariate.dfa}\pysiglinewithargsret{\code{pyrem.univariate.}\bfcode{dfa}}{\emph{X}, \emph{Ave=None}, \emph{L=None}, \emph{sampling=1}}{}
WIP on this function. It is basically copied and pasted from {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}}, without verification of the maths or unittests.

\end{fulllineitems}

\index{fisher\_info() (in module pyrem.univariate)}

\begin{fulllineitems}
\phantomsection\label{pyrem.univariate:pyrem.univariate.fisher_info}\pysiglinewithargsret{\code{pyrem.univariate.}\bfcode{fisher\_info}}{\emph{a}, \emph{tau}, \emph{de}}{}
Compute the Fisher information of a signal with embedding dimension ``de'' and delay ``tau'' {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}}.
Vectorised (i.e. faster) version of the eponymous PyEEG function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{a} (\href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}} or {\hyperref[pyrem.time_series:pyrem.time_series.Signal]{\code{Signal}}}) -- a one dimensional floating-point array representing a time series.

\item {} 
\textbf{tau} (\href{http://docs.python.org/2.7/library/functions.html\#int}{\emph{int}}) -- the delay

\item {} 
\textbf{de} (\href{http://docs.python.org/2.7/library/functions.html\#int}{\emph{int}}) -- the embedding dimension

\end{itemize}

\item[{Returns}] \leavevmode
the Fisher information, a scalar

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{hfd() (in module pyrem.univariate)}

\begin{fulllineitems}
\phantomsection\label{pyrem.univariate:pyrem.univariate.hfd}\pysiglinewithargsret{\code{pyrem.univariate.}\bfcode{hfd}}{\emph{a}, \emph{k\_max}}{}
Compute Higuchi Fractal Dimension of a time series.
Vectorised version of the eponymous {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}} function.

\begin{notice}{note}{Note:}
\textbf{Difference with PyEEG:}

Results is different from {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}} which appears to have implemented an erroneous formulae.
{\hyperref[pyrem.univariate:hig88]{{[}HIG88{]}}} defines the normalisation factor as:
\begin{gather}
\begin{split}\frac{N-1}{[\frac{N-m}{k} ]\dot{} k}\end{split}\notag
\end{gather}
{\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}} implementation uses:
\begin{gather}
\begin{split}\frac{N-1}{[\frac{N-m}{k}]}\end{split}\notag
\end{gather}
The latter does \emph{not} give the expected fractal dimension of approximately \emph{1.50} for brownian motion (see example bellow).
\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{a} (\href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}} or {\hyperref[pyrem.time_series:pyrem.time_series.Signal]{\code{Signal}}}) -- a one dimensional floating-point array representing a time series.

\item {} 
\textbf{k\_max} (\href{http://docs.python.org/2.7/library/functions.html\#int}{\emph{int}}) -- the maximal value of k

\end{itemize}

\item[{Returns}] \leavevmode
Higuchi's fractal dimension; a scalar

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

Example from {\hyperref[pyrem.univariate:hig88]{{[}HIG88{]}}}. This should produce a result close to \emph{1.50}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pyrem} \PYG{k+kn}{as} \PYG{n+nn}{pr}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{i} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{15}\PYG{p}{)} \PYG{o}{+}\PYG{l+m+mi}{1001}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{15}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1001}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pr}\PYG{o}{.}\PYG{n}{univariate}\PYG{o}{.}\PYG{n}{hfd}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{hjorth() (in module pyrem.univariate)}

\begin{fulllineitems}
\phantomsection\label{pyrem.univariate:pyrem.univariate.hjorth}\pysiglinewithargsret{\code{pyrem.univariate.}\bfcode{hjorth}}{\emph{a}}{}
Compute Hjorth parameters {\hyperref[pyrem.univariate:hjo70]{{[}HJO70{]}}}.
\begin{gather}
\begin{split}Activity = m_0 = \sigma_{a}^2\end{split}\notag
\end{gather}\begin{gather}
\begin{split}Complexity = m_2 = \sigma_{d}/ \sigma_{a}\end{split}\notag
\end{gather}\begin{gather}
\begin{split}Morbidity = m_4 =  \frac{\sigma_{dd}/ \sigma_{d}}{m_2}\end{split}\notag
\end{gather}
Where:

\(\sigma_{x}^2\) is the mean power of a signal \(x\). That is, its variance, if it's mean is zero.

\(a\), \(d\) and \(dd\) represent the original signal, its first and second derivatives, respectively.

\begin{notice}{note}{Note:}
\textbf{Difference with PyEEG:}

Results is different from {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}} which appear to uses a non normalised (by the length of the signal) definition of the activity:
\begin{gather}
\begin{split}\sigma_{a}^2 = \sum{\mathbf{x}[i]^2}\end{split}\notag
\end{gather}
As opposed to
\begin{gather}
\begin{split}\sigma_{a}^2 = \frac{1}{n}\sum{\mathbf{x}[i]^2}\end{split}\notag
\end{gather}\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{a} (\href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}} or {\hyperref[pyrem.time_series:pyrem.time_series.Signal]{\code{Signal}}}) -- a one dimensional floating-point array representing a time series.

\item[{Returns}] \leavevmode
activity, complexity and morbidity

\item[{Return type}] \leavevmode
tuple(float, float, float)

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pyrem} \PYG{k+kn}{as} \PYG{n+nn}{pr}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} generate white noise:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{noise} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{1e4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{activity}\PYG{p}{,} \PYG{n}{complexity}\PYG{p}{,} \PYG{n}{morbidity} \PYG{o}{=} \PYG{n}{pr}\PYG{o}{.}\PYG{n}{univariate}\PYG{o}{.}\PYG{n}{hjorth}\PYG{p}{(}\PYG{n}{noise}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{hurst() (in module pyrem.univariate)}

\begin{fulllineitems}
\phantomsection\label{pyrem.univariate:pyrem.univariate.hurst}\pysiglinewithargsret{\code{pyrem.univariate.}\bfcode{hurst}}{\emph{signal}}{}
\textbf{Experimental}/untested implementation taken from:
\href{http://drtomstarke.com/index.php/calculation-of-the-hurst-exponent-to-test-for-trend-and-mean-reversion/}{http://drtomstarke.com/index.php/calculation-of-the-hurst-exponent-to-test-for-trend-and-mean-reversion/}

Use at your own risks.

\end{fulllineitems}

\index{pfd() (in module pyrem.univariate)}

\begin{fulllineitems}
\phantomsection\label{pyrem.univariate:pyrem.univariate.pfd}\pysiglinewithargsret{\code{pyrem.univariate.}\bfcode{pfd}}{\emph{a}}{}
Compute Petrosian Fractal Dimension of a time series {\hyperref[pyrem.univariate:pet95]{{[}PET95{]}}}.

It is defined by:
\begin{gather}
\begin{split}\frac{log(N)}{log(N) + log(\frac{N}{N+0.4N_{\delta}})}\end{split}\notag
\end{gather}
\begin{notice}{note}{Note:}
\textbf{Difference with PyEEG:}

Results is different from {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}} which implemented an apparently erroneous formulae:
\begin{gather}
\begin{split}\frac{log(N)}{log(N) + log(\frac{N}{N}+0.4N_{\delta})}\end{split}\notag
\end{gather}\end{notice}

Where:

\(N\) is the length of the time series, and

\(N_{\delta}\) is the number of sign changes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{a} (\href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}} or {\hyperref[pyrem.time_series:pyrem.time_series.Signal]{\code{Signal}}}) -- a one dimensional floating-point array representing a time series.

\item[{Returns}] \leavevmode
the Petrosian Fractal Dimension; a scalar.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pyrem} \PYG{k+kn}{as} \PYG{n+nn}{pr}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} generate white noise:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{noise} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{1e4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pr}\PYG{o}{.}\PYG{n}{univariate}\PYG{o}{.}\PYG{n}{pdf}\PYG{p}{(}\PYG{n}{noise}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{samp\_entropy() (in module pyrem.univariate)}

\begin{fulllineitems}
\phantomsection\label{pyrem.univariate:pyrem.univariate.samp_entropy}\pysiglinewithargsret{\code{pyrem.univariate.}\bfcode{samp\_entropy}}{\emph{a}, \emph{m}, \emph{r}, \emph{tau=1}, \emph{relative\_r=True}}{}
Compute the sample entropy {\hyperref[pyrem.univariate:ric00]{{[}RIC00{]}}} of a signal with embedding dimension \emph{de} and delay \emph{tau} {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}}.
Vectorised version of the eponymous PyEEG function.
In addition, this function can also be used to vary tau and therefore compute Multi-Scale Entropy(MSE) {\hyperref[pyrem.univariate:cos05]{{[}COS05{]}}} by
coarse grainning the time series (see example bellow).
By default, r is expressed as relatively to the standard deviation of the signal.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{a} (\href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}} or {\hyperref[pyrem.time_series:pyrem.time_series.Signal]{\code{Signal}}}) -- a one dimensional floating-point array representing a time series.

\item {} 
\textbf{m} (\href{http://docs.python.org/2.7/library/functions.html\#int}{\emph{int}}) -- the scale

\item {} 
\textbf{r} (\href{http://docs.python.org/2.7/library/functions.html\#float}{\emph{float}}) -- The tolerance

\item {} 
\textbf{tau} (\href{http://docs.python.org/2.7/library/functions.html\#int}{\emph{int}}) -- The scale for coarse grainning.

\item {} 
\textbf{relative\_r} (\emph{true}) -- whether the argument r is relative to the standard deviation. If false, an absolute value should be given for r.

\end{itemize}

\item[{Returns}] \leavevmode
the approximate entropy, a scalar

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pyrem} \PYG{k+kn}{as} \PYG{n+nn}{pr}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} generate white noise:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{noise} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{1e4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pr}\PYG{o}{.}\PYG{n}{univariate}\PYG{o}{.}\PYG{n}{samp\PYGZus{}entropy}\PYG{p}{(}\PYG{n}{noise}\PYG{p}{,} \PYG{n}{m}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} now we can do that for multiple scales (MSE):}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{n}{pr}\PYG{o}{.}\PYG{n}{univariate}\PYG{o}{.}\PYG{n}{samp\PYGZus{}entropy}\PYG{p}{(}\PYG{n}{noise}\PYG{p}{,} \PYG{n}{m}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{n}{tau}\PYG{o}{=}\PYG{n}{tau}\PYG{p}{)} \PYG{k}{for} \PYG{n}{tau} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]}
\end{Verbatim}

\end{fulllineitems}

\index{spectral\_entropy() (in module pyrem.univariate)}

\begin{fulllineitems}
\phantomsection\label{pyrem.univariate:pyrem.univariate.spectral_entropy}\pysiglinewithargsret{\code{pyrem.univariate.}\bfcode{spectral\_entropy}}{\emph{a}, \emph{sampling\_freq}, \emph{bands=None}}{}
Compute spectral entropy of a  signal with respect to frequency bands.
The power spectrum is computed through fft. Then, it is normalised and assimilated to a probability density function.
The entropy of the signal \(x\) can be expressed by:
\begin{gather}
\begin{split}H(x) =  -\sum_{f=0}^{f = f_s/2} PSD(f) log_2[PSD(f)]\end{split}\notag
\end{gather}
Where:

\(PSD\) is the normalised power spectrum (Power Spectrum Density), and

\(f_s\) is the sampling frequency
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{a} (\href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}} or {\hyperref[pyrem.time_series:pyrem.time_series.Signal]{\code{Signal}}}) -- a one dimensional floating-point array representing a time series.

\item {} 
\textbf{sampling\_freq} (\href{http://docs.python.org/2.7/library/functions.html\#float}{\emph{float}}) -- the sampling frequency

\item {} 
\textbf{bands} -- a list of numbers delimiting the bins of the frequency bands. If None the entropy is computed over the whole range of the DFT (from 0 to \(f_s/2\))

\end{itemize}

\item[{Returns}] \leavevmode
the spectral entropy; a scalar

\end{description}\end{quote}

\end{fulllineitems}

\index{svd\_entropy() (in module pyrem.univariate)}

\begin{fulllineitems}
\phantomsection\label{pyrem.univariate:pyrem.univariate.svd_entropy}\pysiglinewithargsret{\code{pyrem.univariate.}\bfcode{svd\_entropy}}{\emph{a}, \emph{tau}, \emph{de}}{}
Compute the Singular Value Decomposition entropy of a signal with embedding dimension ``de'' and delay ``tau'' {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}}.

\begin{notice}{note}{Note:}
\textbf{Difference with PyEEG:}

The result differs from PyEEG implementation because \(log_2\) is used (as opposed to natural logarithm in PyEEG code),
according to the definition in their paper {\hyperref[pyrem.univariate:pyeeg]{{[}PYEEG{]}}} (eq. 9):
\begin{gather}
\begin{split}H_{SVD} = -\sum{\bar\sigma{}_i log_2 \bar\sigma{}_i}\end{split}\notag
\end{gather}\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{a} (\href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\#numpy.ndarray}{\code{ndarray}} or {\hyperref[pyrem.time_series:pyrem.time_series.Signal]{\code{Signal}}}) -- a one dimensional floating-point array representing a time series.

\item {} 
\textbf{tau} (\href{http://docs.python.org/2.7/library/functions.html\#int}{\emph{int}}) -- the delay

\item {} 
\textbf{de} (\href{http://docs.python.org/2.7/library/functions.html\#int}{\emph{int}}) -- the embedding dimension

\end{itemize}

\item[{Returns}] \leavevmode
the SVD entropy, a scalar

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\section{pyrem.visualization module}
\label{pyrem.visualization:module-pyrem.visualization}\label{pyrem.visualization::doc}\label{pyrem.visualization:pyrem-visualization-module}\index{pyrem.visualization (module)}
This is prototypical early visualisation module.
It allows visualisation of {\hyperref[pyrem.polygram:pyrem.polygram.Polygram]{\code{Polygram}}} objects using matplotlib.
In the future, The visualisation tool should be faster and more interactive.
It is likely to become independent of matplotlib.
\index{PolygramDisplay (class in pyrem.visualization)}

\begin{fulllineitems}
\phantomsection\label{pyrem.visualization:pyrem.visualization.PolygramDisplay}\pysiglinewithargsret{\strong{class }\code{pyrem.visualization.}\bfcode{PolygramDisplay}}{\emph{polygram}, \emph{max\_point\_amplitude\_plot=1000}}{}
Bases: \code{object}
\index{show() (pyrem.visualization.PolygramDisplay method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.visualization:pyrem.visualization.PolygramDisplay.show}\pysiglinewithargsret{\bfcode{show}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\section{pyrem.wavelet\_decomposition module}
\label{pyrem.wavelet_decomposition::doc}\label{pyrem.wavelet_decomposition:module-pyrem.wavelet_decomposition}\label{pyrem.wavelet_decomposition:pyrem-wavelet-decomposition-module}\index{pyrem.wavelet\_decomposition (module)}\index{decompose\_signal() (in module pyrem.wavelet\_decomposition)}

\begin{fulllineitems}
\phantomsection\label{pyrem.wavelet_decomposition:pyrem.wavelet_decomposition.decompose_signal}\pysiglinewithargsret{\code{pyrem.wavelet\_decomposition.}\bfcode{decompose\_signal}}{\emph{signal}, \emph{levels=(1}, \emph{2}, \emph{3}, \emph{4}, \emph{5)}, \emph{wavelet='db4'}, \emph{resample\_before=None}, \emph{mode='per'}, \emph{keep\_a=True}}{}
A wrapper around \href{http://www.pybytes.com/pywavelets/ref/dwt-discrete-wavelet-transform.html\#pywt.wavedec}{\code{wavedec()}}. It performs discrete wavelet decomposition and return the coefficients as a {\hyperref[pyrem.polygram:pyrem.polygram.Polygram]{\code{pyrem.polygram.Polygram}}}.
It allows to select the wavelet coefficients to keep and can perform preliminary resampling of the signal.
In the resulting polygram, the names of the coefficients will be suffixed by an an identifier describing their respective levels (i.e. cD\_1, cD\_2, ..., cD\_N, cA\_N).
The sampling frequency of coefficients will also be automatically computed.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pyrem} \PYG{k+kn}{as} \PYG{n+nn}{pr}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{noise} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{1e6}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sig} \PYG{o}{=} \PYG{n}{pr}\PYG{o}{.}\PYG{n}{time\PYGZus{}series}\PYG{o}{.}\PYG{n}{Signal}\PYG{p}{(}\PYG{n}{noise}\PYG{p}{,} \PYG{l+m+mf}{256.0}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }     \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{channel\PYGZus{}1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }     \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{channel\PYGZus{}1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pol} \PYG{o}{=} \PYG{n}{pr}\PYG{o}{.}\PYG{n}{wavelet\PYGZus{}decomposition} \PYG{n}{decompose\PYGZus{}signal}\PYG{p}{(}\PYG{n}{sig}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pol}
\PYG{g+go}{    Polygram}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{    Duration:       1:05:06.250000 (HH:mm:ss)}
\PYG{g+go}{    N signals:      6}
\PYG{g+go}{    N annotations:  0}
\PYG{g+go}{    Metadata:}
\PYG{g+go}{            None}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{    Channel information:}
\PYG{g+go}{                 Name  Type fs(Hz)        Duration}
\PYG{g+go}{    0  channel\PYGZus{}1\PYGZus{}cA\PYGZus{}5  None    8.0  1:05:06.250000}
\PYG{g+go}{    1  channel\PYGZus{}1\PYGZus{}cD\PYGZus{}1  None  128.0  1:05:06.250000}
\PYG{g+go}{    2  channel\PYGZus{}1\PYGZus{}cD\PYGZus{}2  None   64.0  1:05:06.250000}
\PYG{g+go}{    3  channel\PYGZus{}1\PYGZus{}cD\PYGZus{}3  None   32.0  1:05:06.250000}
\PYG{g+go}{    4  channel\PYGZus{}1\PYGZus{}cD\PYGZus{}4  None   16.0  1:05:06.250000}
\PYG{g+go}{    5  channel\PYGZus{}1\PYGZus{}cD\PYGZus{}5  None    8.0  1:05:06.250000}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{signal} ({\hyperref[pyrem.time_series:pyrem.time_series.Signal]{\code{pyrem.time\_series.Signal}}}) -- the time series to be decomposed

\item {} 
\textbf{levels} (\emph{list({[}int{]})}) -- the levels to keep (e.g. {[}1,2,3,5{]}) will not return the coeficient cD\_4

\item {} 
\textbf{wavelet} (\href{http://docs.python.org/2.7/library/functions.html\#str}{\emph{str}}) -- the type of wavelet (see \href{http://www.pybytes.com/pywavelets/ref/dwt-discrete-wavelet-transform.html\#pywt.wavedec}{\code{wavedec()}})

\item {} 
\textbf{resample\_before} (\href{http://docs.python.org/2.7/library/functions.html\#float}{\emph{float}}) -- the sampling frequency at which to resample the signal before the decomposition

\item {} 
\textbf{mode} (\href{http://docs.python.org/2.7/library/functions.html\#str}{\emph{str}}) -- (see \href{http://www.pybytes.com/pywavelets/ref/dwt-discrete-wavelet-transform.html\#pywt.wavedec}{\code{wavedec()}})

\item {} 
\textbf{keep\_a} -- whether to keep the last coefficient (cA\_N)

\end{itemize}

\item[{Returns}] \leavevmode
A polygram with all the requested coefficients

\item[{Return type}] \leavevmode
{\hyperref[pyrem.polygram:pyrem.polygram.Polygram]{\code{pyrem.polygram.Polygram}}}

\end{description}\end{quote}

\end{fulllineitems}



\section{pyrem.feature\_families module}
\label{pyrem.feature_families:pyrem-feature-families-module}\label{pyrem.feature_families::doc}\label{pyrem.feature_families:module-pyrem.feature_families}\index{pyrem.feature\_families (module)}
The goal of this submodule is to provide a flexible interface to compute arbitrary features on each channel and epoch (temporal slices) of a multivariate time series (Polygraph).
Features are grouped in families of several features (e.g. Power Features may contain mean power, variance of power, ...).
Feature factory computes features for arbitrary feature families and group them in a data.frame
\index{AbsoluteFeatures (class in pyrem.feature\_families)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.AbsoluteFeatures}\pysigline{\strong{class }\code{pyrem.feature\_families.}\bfcode{AbsoluteFeatures}}
Bases: {\hyperref[pyrem.feature_families:pyrem.feature_families.SignalFeatureBase]{\code{pyrem.feature\_families.SignalFeatureBase}}}
\index{prefix (pyrem.feature\_families.AbsoluteFeatures attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.AbsoluteFeatures.prefix}\pysigline{\bfcode{prefix}\strong{ = `abs'}}
\end{fulllineitems}


\end{fulllineitems}

\index{AnnotationFeatureBase (class in pyrem.feature\_families)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.AnnotationFeatureBase}\pysigline{\strong{class }\code{pyrem.feature\_families.}\bfcode{AnnotationFeatureBase}}
Bases: {\hyperref[pyrem.feature_families:pyrem.feature_families.FeatureFamilyBase]{\code{pyrem.feature\_families.FeatureFamilyBase}}}

\end{fulllineitems}

\index{EntropyFeatures (class in pyrem.feature\_families)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.EntropyFeatures}\pysigline{\strong{class }\code{pyrem.feature\_families.}\bfcode{EntropyFeatures}}
Bases: {\hyperref[pyrem.feature_families:pyrem.feature_families.SignalFeatureBase]{\code{pyrem.feature\_families.SignalFeatureBase}}}
\index{prefix (pyrem.feature\_families.EntropyFeatures attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.EntropyFeatures.prefix}\pysigline{\bfcode{prefix}\strong{ = `entropy'}}
\end{fulllineitems}


\end{fulllineitems}

\index{FeatureFamilyBase (class in pyrem.feature\_families)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.FeatureFamilyBase}\pysigline{\strong{class }\code{pyrem.feature\_families.}\bfcode{FeatureFamilyBase}}
Bases: \code{object}

A feature family object is a process returning a vector of features upon analysis of some data.
Features are returned as a pandas DataFrame object, with column names for features. Each feature name is prefixed by the name of the
feature family. This is an abstract class designed to be derived by:
\begin{enumerate}
\item {} 
Defining a \code{prefix} attribute. It will add the name of the family to the name of the features.

\item {} 
Overriding the \code{\_make\_feature\_vec} method. It should return a dictionary of scalars, each being a feature.

\end{enumerate}
\index{make\_vector() (pyrem.feature\_families.FeatureFamilyBase method)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.FeatureFamilyBase.make_vector}\pysiglinewithargsret{\bfcode{make\_vector}}{\emph{signal}}{}
Compute one vector of features from polygraph.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{data} (\code{Polygraph}) -- A signal

\item[{Returns}] \leavevmode
a one-row dataframe

\item[{Return type}] \leavevmode
\href{http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html\#pandas.DataFrame}{\code{DataFrame}}

\end{description}\end{quote}

\end{fulllineitems}

\index{prefix (pyrem.feature\_families.FeatureFamilyBase attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.FeatureFamilyBase.prefix}\pysigline{\bfcode{prefix}\strong{ = None}}
\end{fulllineitems}


\end{fulllineitems}

\index{FractalFeatures (class in pyrem.feature\_families)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.FractalFeatures}\pysigline{\strong{class }\code{pyrem.feature\_families.}\bfcode{FractalFeatures}}
Bases: {\hyperref[pyrem.feature_families:pyrem.feature_families.SignalFeatureBase]{\code{pyrem.feature\_families.SignalFeatureBase}}}
\index{prefix (pyrem.feature\_families.FractalFeatures attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.FractalFeatures.prefix}\pysigline{\bfcode{prefix}\strong{ = `fractal'}}
\end{fulllineitems}


\end{fulllineitems}

\index{HjorthFeatures (class in pyrem.feature\_families)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.HjorthFeatures}\pysigline{\strong{class }\code{pyrem.feature\_families.}\bfcode{HjorthFeatures}}
Bases: {\hyperref[pyrem.feature_families:pyrem.feature_families.SignalFeatureBase]{\code{pyrem.feature\_families.SignalFeatureBase}}}
\index{prefix (pyrem.feature\_families.HjorthFeatures attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.HjorthFeatures.prefix}\pysigline{\bfcode{prefix}\strong{ = `hjorth'}}
\end{fulllineitems}


\end{fulllineitems}

\index{NonLinearFeatures (class in pyrem.feature\_families)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.NonLinearFeatures}\pysigline{\strong{class }\code{pyrem.feature\_families.}\bfcode{NonLinearFeatures}}
Bases: {\hyperref[pyrem.feature_families:pyrem.feature_families.SignalFeatureBase]{\code{pyrem.feature\_families.SignalFeatureBase}}}
\index{prefix (pyrem.feature\_families.NonLinearFeatures attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.NonLinearFeatures.prefix}\pysigline{\bfcode{prefix}\strong{ = `nl'}}
\end{fulllineitems}


\end{fulllineitems}

\index{PeriodogramFeatures (class in pyrem.feature\_families)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.PeriodogramFeatures}\pysigline{\strong{class }\code{pyrem.feature\_families.}\bfcode{PeriodogramFeatures}}
Bases: {\hyperref[pyrem.feature_families:pyrem.feature_families.SignalFeatureBase]{\code{pyrem.feature\_families.SignalFeatureBase}}}
\index{prefix (pyrem.feature\_families.PeriodogramFeatures attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.PeriodogramFeatures.prefix}\pysigline{\bfcode{prefix}\strong{ = `spectr'}}
\end{fulllineitems}


\end{fulllineitems}

\index{PowerFeatures (class in pyrem.feature\_families)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.PowerFeatures}\pysigline{\strong{class }\code{pyrem.feature\_families.}\bfcode{PowerFeatures}}
Bases: {\hyperref[pyrem.feature_families:pyrem.feature_families.SignalFeatureBase]{\code{pyrem.feature\_families.SignalFeatureBase}}}
\index{prefix (pyrem.feature\_families.PowerFeatures attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.PowerFeatures.prefix}\pysigline{\bfcode{prefix}\strong{ = `power'}}
\end{fulllineitems}


\end{fulllineitems}

\index{SignalFeatureBase (class in pyrem.feature\_families)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.SignalFeatureBase}\pysigline{\strong{class }\code{pyrem.feature\_families.}\bfcode{SignalFeatureBase}}
Bases: {\hyperref[pyrem.feature_families:pyrem.feature_families.FeatureFamilyBase]{\code{pyrem.feature\_families.FeatureFamilyBase}}}

\end{fulllineitems}

\index{VigilState (class in pyrem.feature\_families)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.VigilState}\pysigline{\strong{class }\code{pyrem.feature\_families.}\bfcode{VigilState}}
Bases: {\hyperref[pyrem.feature_families:pyrem.feature_families.AnnotationFeatureBase]{\code{pyrem.feature\_families.AnnotationFeatureBase}}}
\index{prefix (pyrem.feature\_families.VigilState attribute)}

\begin{fulllineitems}
\phantomsection\label{pyrem.feature_families:pyrem.feature_families.VigilState.prefix}\pysigline{\bfcode{prefix}\strong{ = `vigil'}}
\end{fulllineitems}


\end{fulllineitems}



\section{pyrem.io module}
\label{pyrem.io:module-pyrem.io}\label{pyrem.io:pyrem-io-module}\label{pyrem.io::doc}\index{pyrem.io (module)}\index{polygram\_from\_pkl() (in module pyrem.io)}

\begin{fulllineitems}
\phantomsection\label{pyrem.io:pyrem.io.polygram_from_pkl}\pysiglinewithargsret{\code{pyrem.io.}\bfcode{polygram\_from\_pkl}}{\emph{filename}}{}
\end{fulllineitems}

\index{polygram\_from\_spike\_matlab\_file() (in module pyrem.io)}

\begin{fulllineitems}
\phantomsection\label{pyrem.io:pyrem.io.polygram_from_spike_matlab_file}\pysiglinewithargsret{\code{pyrem.io.}\bfcode{polygram\_from\_spike\_matlab\_file}}{\emph{signal\_filename}, \emph{annotation\_filename}, \emph{fs}, \emph{annotation\_fs}, \emph{channel\_names}, \emph{channel\_types}, \emph{doubt\_chars}, \emph{resample\_signals}, \emph{metadata=\{\}}}{}
This function loads a matlab file exported by spike to
as a polygraph.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal\_filename} -- the matlab file name

\item[{Returns}] \leavevmode
a polygram

\end{description}\end{quote}

\end{fulllineitems}

\index{signal\_from\_pkl() (in module pyrem.io)}

\begin{fulllineitems}
\phantomsection\label{pyrem.io:pyrem.io.signal_from_pkl}\pysiglinewithargsret{\code{pyrem.io.}\bfcode{signal\_from\_pkl}}{\emph{filename}}{}
\end{fulllineitems}



\section{pyrem.utils module}
\label{pyrem.utils:pyrem-utils-module}\label{pyrem.utils::doc}\label{pyrem.utils:module-pyrem.utils}\index{pyrem.utils (module)}\index{str\_to\_time() (in module pyrem.utils)}

\begin{fulllineitems}
\phantomsection\label{pyrem.utils:pyrem.utils.str_to_time}\pysiglinewithargsret{\code{pyrem.utils.}\bfcode{str\_to\_time}}{\emph{str}}{}
Parse a string describing a duration as a \href{http://docs.python.org/2.7/library/datetime.html\#datetime.timedelta}{\code{timedelta}}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\href{http://docs.python.org/2.7/library/functions.html\#str}{\emph{str}}) -- a string with the format ``XhYmZs''. where XYZ are integers (or floats)

\item[{Returns}] \leavevmode
a timedelta corresponding to the \emph{str} argument

\item[{Return type}] \leavevmode
timedelta

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}

\begin{thebibliography}{PET95}
\bibitem[EDF]{EDF}{\phantomsection\label{pyrem.polygram:edf} 
B. Kemp and J. Olivan, ``European data format `plus' (EDF+), an EDF alike standard format for the exchange of physiological data,''
Clinical Neurophysiology, vol. 114, no. 9, pp. 1755-1761, Sep. 2003.
}
\bibitem[PET95]{PET95}{\phantomsection\label{pyrem.univariate:pet95} 
A. Petrosian, Kolmogorov complexity of finite sequences and recognition of different preictal EEG patterns, in ,
Proceedings of the Eighth IEEE Symposium on Computer-Based Medical Systems, 1995, 1995, pp. 212-217.
}
\bibitem[PYEEG]{PYEEG}{\phantomsection\label{pyrem.univariate:pyeeg} 
F. S. Bao, X. Liu, and C. Zhang, PyEEG: An Open Source Python Module for EEG/MEG Feature Extraction,
Computational Intelligence and Neuroscience, vol. 2011, p. e406391, Mar. 2011.
}
\bibitem[HJO70]{HJO70}{\phantomsection\label{pyrem.univariate:hjo70} 
B. Hjorth, EEG analysis based on time domain properties,
Electroencephalography and Clinical Neurophysiology, vol. 29, no. 3, pp. 306-310, Sep. 1970.
}
\bibitem[COS05]{COS05}{\phantomsection\label{pyrem.univariate:cos05} \begin{enumerate}
\setcounter{enumi}{12}
\item {} 
Costa, A. L. Goldberger, and C.-K. Peng, ``Multiscale entropy analysis of biological signals,'' Phys. Rev. E, vol. 71, no. 2, p. 021906, Feb. 2005.

\end{enumerate}
}
\bibitem[RIC00]{RIC00}{\phantomsection\label{pyrem.univariate:ric00} 
J. S. Richman and J. R. Moorman, ``Physiological time-series analysis using approximate entropy and sample entropy,''
American Journal of Physiology - Heart and Circulatory Physiology, vol. 278, no. 6, pp. H2039-H2049, Jun. 2000.
}
\bibitem[HIG88]{HIG88}{\phantomsection\label{pyrem.univariate:hig88} \begin{enumerate}
\setcounter{enumi}{19}
\item {} 
Higuchi, ``Approach to an irregular time series on the basis of the fractal theory,'' Physica D: Nonlinear Phenomena, vol. 31, no. 2, pp. 277-283, Jun. 1988.

\end{enumerate}
}
\end{thebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{pyrem}}, \pageref{index:module-pyrem}
\item {\texttt{pyrem.feature\_families}}, \pageref{pyrem.feature_families:module-pyrem.feature_families}
\item {\texttt{pyrem.io}}, \pageref{pyrem.io:module-pyrem.io}
\item {\texttt{pyrem.polygram}}, \pageref{pyrem.polygram:module-pyrem.polygram}
\item {\texttt{pyrem.time\_series}}, \pageref{pyrem.time_series:module-pyrem.time_series}
\item {\texttt{pyrem.univariate}}, \pageref{pyrem.univariate:module-pyrem.univariate}
\item {\texttt{pyrem.utils}}, \pageref{pyrem.utils:module-pyrem.utils}
\item {\texttt{pyrem.visualization}}, \pageref{pyrem.visualization:module-pyrem.visualization}
\item {\texttt{pyrem.wavelet\_decomposition}}, \pageref{pyrem.wavelet_decomposition:module-pyrem.wavelet_decomposition}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
