\section{Results} \label{results}

\subsection{\texttt{Python} package}
Several algorithms to extract features from univariate time series had already been implemented in the \py{} package \pyeeg{}\citationneeded{}.
Unfortunately, some of them were critically slow, and could therefore not realistically have been used in the present study.
Preliminary investigation of the source code revealed that runtimes may be improved by vectorising expressions and pre-allocating of temporary arrays.
Therefore, systematic reimplementation of all algorithms in \pyeeg{} was undertaken.
Very significant improvement in performance were achieved (table~\ref{tab:benchmark}).

\input{./tables/benchmark}

Importantly, several mathematical inconsistancies between the original code and the mathematical definitions were also noticed.
This affected five of the eight reimplemented functions(table~\ref{tab:benchmark}). 
Detail of the corrections performed are provided, as notes, in the documentation of the new package\TODO{ref appendix}.
Numerical results for the three other functions were consitstant throughout optimisation.

In order to facilitate feature extraction, several data structures and routines were also implemented 
in a new python package named \pr{}.
Briefly, extentions of \texttt{numpy} arrays providing metadata, sampling frequency, and other attributes were used to represent time series.
User friendly indexing with string representing time was also developed.
In addition, a container for time series of discrete annotation levels, each linked to a confidence level, was built.
Importantly, a container for multiple time series, which supports heterogeneous (between time series) sampling frequencies was implemented.
The new package also provides visualisation, input/output, and wrappers for resampling and discrete wavelet decomposition.
Finally, unittests were implemented to ensure presistance of mathematical and programmatic validity though-out developmental stage.
A full documentation of \pr{} is provided in the appendix\TODO{ref} of the report herein.

\subsection{Variable elimination}
Including temporal features, by lag (eq.~\ref{eq:tau}) or by convolution (eq.~\ref{eq:window}), results in multiplication the number of variable, rendering computation difficult, and prediction potentially less accurate.
Therefore, iterative eliminatation of variables based on their importance.
Starting with all 164 variables, random forests were trained, and the number of features was reduced by a factor $1.3$  by eliminating the least important variables.
For each iteration, the stratified cross validation error (see material and methods) was computed (fig.~\ref{fig:variable_elimination}).

\input{./figures/variable_elimination}

The predictive accuracy globally increases with the number of variables.
...
No stats?!
...
However, this increase is very moderate for ($p>8$) this indicates that complexity can be reduces without largely impacting accuracy.
For further investigation, $p=20$ was considered to be a good compromise between error and computationnal load.
\TODO{table importance of the 20 variables ?!}

\subsection{Including temporal information}
Manual scorer usualy use contextual information in order to make a decision concerning a given state.
For instance, implicit assumptions are made on the temporal consistency of the states.
Therefore, it seems interesting to account for contextual information.
In this study, two different approaches were pursued.
Either the local means of features over different ranges were added to the features of each epochs (eq.~\ref{eq:window}), 
or the features of neighbouring time points were included (eq.~\ref{eq:tau}).

A comparison of both approaches is proposed in figure \ref{fig:temporal_integration}.
Significant improvement was acchieved by both methods by including even little temporal information ($\tau = 1$, $n=\{1,3\}$).
The best accuracy was acchieved with $\tau = 2$. 
This value is also a good compromise in so far as it only inflates $p$ by five fold.
In addition, it is advantageous to requiere only five contiguous neighbouring epochs instead of having to integrate minutes of contextual information.
Combining both approches did not improve prediction any further (data not shown).

\input{./figures/temporal_integration}


\subsection{Prediction results}

\input{./figures/struct_assess}

After selecting and defining new variables, general and structural of the classifier was assessed.
For this purpose, random forests were trained on samples accounting for the unbalanced prevalence.
Predictions were generated using the same startified sampling approach. 
That is, prediction on each time series were made by a classifier for which the training set did not contain any point of this time series.

The overall relative confusion matrix is presented in table \ref{tab:confus}
... the overall error rate was...

In order to investigate the structural differences between ground truth and the predicted states,
three metrics describing physiological properties of sleep were computed (fig.~\ref{fig:struct_assess}).

Prevalence(fig.~\ref{fig:struct_assess}A) of states appears to be the most widely uses metric to describe sleep patterns\citationneeded{}. 

No significant difference was found between the ground truth and predicted prevalences ($p-value > 0.13$ for all, z test on the interaction terms of $\beta$ regression).

Sleep fragmentation is often assessed through a combination of two variables: number of episodes of a given state (fig.~\ref{fig:struct_assess}B) and average duration of all episodes per state (fig.~\ref{fig:struct_assess}C) \citationneeded{}.

Large differences were observed between the number of events computed from the ground truth or the predicted data.
($p-value < 10^{-15}$ for all, t test on the interaction terms of Poison GLMM).

Finally, significant differences were found between methods for the average durations of \gls{rem} ($p-value < 10^{-4}$) an wake ($p-value < 10^{-3}$) episodes
(t test on the interaction terms of linear mixed model).

\subsection{Prediction results}
Since classification can be inacurate, it would be interesting to associate `confidence' score to each prediction.
A entropy based condidence level $c$ (eq. \ref{eq:entropy}) was defined for this purpose.
Then, the average cross-validation error was computed for different degrees of confidence (fig\ref{fig:error}A).
As expected, the probability of misclassification decreases monotonically with $c$.
In addition, error rate seem to tend to zero when the confidence value is one, and, for confidences close to zero, the predictor is very inacurate.
These characterics indicate that $c$ can be used to as a supporting value for predictions.
One application of such a confidence level could be to provide user with an overall quality assement. In addition,
it could be possible to save time by browsing the time series skiping high confidence regions (fig\ref{fig:error}C).
\input{./figures/error}




